#!/usr/bin/env bash
#
# Embedding Generation Pipeline for Humanizer Agent
#
# Intelligently generates embeddings for chunks with filtering:
# - Skips zero-token chunks
# - Skips slash commands
# - Skips low-interest messages ("continue", "yes", "ok", etc.)
# - Configurable minimum token threshold
# - Uses Ollama (mxbai-embed-large) for local embedding generation
#
# Usage:
#   ./embedgen plan [--min-tokens N]       # Plan what will be embedded (dry run)
#   ./embedgen queue [--min-tokens N]      # Mark chunks for embedding (sets metadata flag)
#   ./embedgen process [--batch-size N]    # Process queued chunks
#   ./embedgen status                      # Show embedding progress
#   ./embedgen reset                       # Clear all embedding queue flags
#   ./embedgen help                        # Show this help message

set -euo pipefail

# Load active database profile
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ACTIVE_PROFILE_FILE="$SCRIPT_DIR/.active_db_profile"
DB_PROFILES_DIR="$SCRIPT_DIR/db_profiles"

# Default to production if no active profile
if [[ -f "$ACTIVE_PROFILE_FILE" ]]; then
    ACTIVE_PROFILE=$(cat "$ACTIVE_PROFILE_FILE")
else
    ACTIVE_PROFILE="production"
fi

# Load environment variables from active profile
PROFILE_ENV="$DB_PROFILES_DIR/${ACTIVE_PROFILE}.env"
if [[ ! -f "$PROFILE_ENV" ]]; then
    echo "❌ Error: Profile '$ACTIVE_PROFILE' not found at $PROFILE_ENV"
    exit 1
fi

# Source the profile (exports DATABASE_URL)
set -a
source "$PROFILE_ENV"
set +a

# Parse DATABASE_URL
DB_URL_NO_PROTO="${DATABASE_URL#postgresql+asyncpg://}"
DB_URL_NO_PROTO="${DB_URL_NO_PROTO#postgresql://}"

if [[ $DB_URL_NO_PROTO =~ ^([^:]+):([^@]+)@([^:]+):([0-9]+)/(.+)$ ]]; then
    DB_USER="${BASH_REMATCH[1]}"
    DB_PASSWORD="${BASH_REMATCH[2]}"
    DB_HOST="${BASH_REMATCH[3]}"
    DB_PORT="${BASH_REMATCH[4]}"
    DB_NAME="${BASH_REMATCH[5]}"
else
    echo "❌ Error: Could not parse DATABASE_URL"
    exit 1
fi

export PGPASSWORD="$DB_PASSWORD"
PSQL_CMD="psql -U $DB_USER -h $DB_HOST -p $DB_PORT -d $DB_NAME"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Default configuration
DEFAULT_MIN_TOKENS=15  # Skip very short chunks
DEFAULT_BATCH_SIZE=100

#------------------------------------------------------------------------------
# Filtering SQL - What chunks should we embed?
#------------------------------------------------------------------------------

# This WHERE clause defines what we consider "high-value" content
FILTER_SQL="
    -- Must have content
    token_count IS NOT NULL
    AND token_count > 0

    -- Minimum token threshold (configurable)
    AND token_count >= MIN_TOKENS_PLACEHOLDER

    -- Skip slash commands
    AND content !~ '^/'

    -- Skip low-interest single-word messages
    AND LOWER(TRIM(content)) NOT IN (
        'continue', 'go on', 'keep going', 'next', 'more',
        'ok', 'yes', 'no', 'k', 'kk', 'yep', 'nope'
    )

    -- Don't re-embed chunks that already have embeddings
    AND embedding IS NULL
"

#------------------------------------------------------------------------------
# Helper Functions
#------------------------------------------------------------------------------

print_header() {
    echo -e "\n${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}\n"
}

print_section() {
    echo -e "\n${BLUE}▶ $1${NC}\n"
}

get_filter_sql() {
    local min_tokens=${1:-$DEFAULT_MIN_TOKENS}
    echo "$FILTER_SQL" | sed "s/MIN_TOKENS_PLACEHOLDER/$min_tokens/g"
}

#------------------------------------------------------------------------------
# Command: plan
#------------------------------------------------------------------------------

cmd_plan() {
    local min_tokens=${1:-$DEFAULT_MIN_TOKENS}

    print_header "Embedding Generation Plan - $ACTIVE_PROFILE"

    echo -e "${BLUE}Configuration:${NC}"
    echo -e "  Minimum tokens: $min_tokens"
    echo -e "  Database: $DB_NAME\n"

    # Overall statistics
    print_section "Overall Statistics"
    $PSQL_CMD -c "
    SELECT
        COUNT(*) as total_chunks,
        COUNT(embedding) as already_embedded,
        COUNT(*) FILTER (WHERE embedding IS NULL) as not_embedded
    FROM chunks;
    "

    # What will be embedded
    print_section "Chunks to Embed (High-Value Content)"
    local filter_sql=$(get_filter_sql "$min_tokens")
    $PSQL_CMD -c "
    SELECT
        COUNT(*) as chunks_to_embed,
        MIN(token_count) as min_tokens,
        MAX(token_count) as max_tokens,
        ROUND(AVG(token_count)) as avg_tokens,
        SUM(token_count) as total_tokens
    FROM chunks
    WHERE $filter_sql;
    "

    # What will be skipped
    print_section "Chunks to Skip (Low-Interest Content)"
    $PSQL_CMD -c "
    SELECT
        'Zero tokens' as skip_reason,
        COUNT(*) as count
    FROM chunks
    WHERE token_count IS NULL OR token_count = 0
    UNION ALL
    SELECT
        'Below minimum (' || $min_tokens || ' tokens)' as skip_reason,
        COUNT(*) as count
    FROM chunks
    WHERE token_count > 0 AND token_count < $min_tokens
        AND content !~ '^/'
        AND LOWER(TRIM(content)) NOT IN ('continue', 'go on', 'keep going', 'next', 'more', 'ok', 'yes', 'no', 'k', 'kk', 'yep', 'nope')
    UNION ALL
    SELECT
        'Slash commands' as skip_reason,
        COUNT(*) as count
    FROM chunks
    WHERE content ~ '^/' AND embedding IS NULL
    UNION ALL
    SELECT
        'Low-interest words' as skip_reason,
        COUNT(*) as count
    FROM chunks
    WHERE LOWER(TRIM(content)) IN ('continue', 'go on', 'keep going', 'next', 'more', 'ok', 'yes', 'no', 'k', 'kk', 'yep', 'nope')
        AND embedding IS NULL
    UNION ALL
    SELECT
        'Already embedded' as skip_reason,
        COUNT(*) as count
    FROM chunks
    WHERE embedding IS NOT NULL;
    "

    # Token distribution of chunks to embed
    print_section "Token Distribution (To Be Embedded)"
    $PSQL_CMD -c "
    SELECT
        token_range,
        COUNT(*) as count
    FROM (
        SELECT
            CASE
                WHEN token_count <= 50 THEN '15-50 tokens'
                WHEN token_count <= 100 THEN '51-100 tokens'
                WHEN token_count <= 500 THEN '101-500 tokens'
                WHEN token_count <= 1000 THEN '501-1000 tokens'
                WHEN token_count <= 5000 THEN '1001-5000 tokens'
                ELSE '5000+ tokens'
            END as token_range,
            CASE
                WHEN token_count <= 50 THEN 1
                WHEN token_count <= 100 THEN 2
                WHEN token_count <= 500 THEN 3
                WHEN token_count <= 1000 THEN 4
                WHEN token_count <= 5000 THEN 5
                ELSE 6
            END as sort_order
        FROM chunks
        WHERE $filter_sql
    ) subq
    GROUP BY token_range, sort_order
    ORDER BY sort_order;
    "

    echo -e "\n${GREEN}✓ Plan complete${NC}"
    echo -e "${YELLOW}Next step:${NC} ./embedgen queue --min-tokens $min_tokens"
}

#------------------------------------------------------------------------------
# Command: queue
#------------------------------------------------------------------------------

cmd_queue() {
    local min_tokens=${1:-$DEFAULT_MIN_TOKENS}

    print_header "Queue Chunks for Embedding - $ACTIVE_PROFILE"

    echo -e "${BLUE}Configuration:${NC}"
    echo -e "  Minimum tokens: $min_tokens"
    echo -e "  Database: $DB_NAME\n"

    # Confirm
    local filter_sql=$(get_filter_sql "$min_tokens")
    local count=$($PSQL_CMD -t -c "SELECT COUNT(*) FROM chunks WHERE $filter_sql;" | tr -d ' ')

    echo -e "${YELLOW}This will mark $count chunks for embedding.${NC}"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    # Update metadata to mark chunks for embedding
    print_section "Marking Chunks for Embedding"
    $PSQL_CMD -c "
    UPDATE chunks
    SET metadata = metadata || jsonb_build_object(
        'embedding_queued', true,
        'embedding_queued_at', CURRENT_TIMESTAMP::text,
        'embedding_filter', 'min_tokens=$min_tokens'
    )
    WHERE $filter_sql;
    "

    echo -e "\n${GREEN}✓ Queued $count chunks for embedding${NC}"
    echo -e "${YELLOW}Next step:${NC} ./embedgen process"
}

#------------------------------------------------------------------------------
# Command: process
#------------------------------------------------------------------------------

cmd_process() {
    local batch_size=${1:-$DEFAULT_BATCH_SIZE}

    print_header "Process Queued Embeddings - $ACTIVE_PROFILE"

    echo -e "${BLUE}Configuration:${NC}"
    echo -e "  Batch size: $batch_size"
    echo -e "  Model: mxbai-embed-large (Ollama)"
    echo -e "  Database: $DB_NAME\n"

    # Check if Ollama is running
    if ! curl -s http://localhost:11434/api/version > /dev/null 2>&1; then
        echo -e "${RED}❌ Error: Ollama is not running${NC}"
        echo "Start Ollama first: ollama serve"
        exit 1
    fi

    # Check for queued chunks
    local queued=$($PSQL_CMD -t -c "
        SELECT COUNT(*)
        FROM chunks
        WHERE embedding IS NULL
        AND metadata->>'embedding_queued' = 'true';
    " | tr -d ' ')

    echo -e "${BLUE}Queued chunks:${NC} $queued\n"

    if [[ $queued -eq 0 ]]; then
        echo "No chunks queued for embedding."
        echo "Run: ./embedgen queue"
        exit 0
    fi

    # Call Python embedding service
    echo -e "${YELLOW}Starting embedding generation...${NC}\n"

    cd "$SCRIPT_DIR"
    source venv/bin/activate

    python3 << PYTHON_SCRIPT
import asyncio
import sys
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from services.embedding_service import EmbeddingService

async def main():
    # Create async engine
    engine = create_async_engine("${DATABASE_URL}", echo=False)
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

    async with async_session() as session:
        service = EmbeddingService(
            model="mxbai-embed-large",
            dimension=1024,
            ollama_url="http://localhost:11434"
        )

        try:
            stats = await service.process_queued_chunks(
                session,
                batch_size=$batch_size,
                max_chunks=None
            )

            print(f"\n✓ Embedding generation complete!")
            print(f"  Processed: {stats['processed']}")
            print(f"  Succeeded: {stats['succeeded']}")
            print(f"  Failed: {stats['failed']}")

            return 0 if stats['failed'] == 0 else 1

        finally:
            await service.close()
            await engine.dispose()

if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
PYTHON_SCRIPT

    echo -e "\n${GREEN}✓ Processing complete${NC}"
    echo -e "${YELLOW}Check status:${NC} ./embedgen status"
}

#------------------------------------------------------------------------------
# Command: status
#------------------------------------------------------------------------------

cmd_status() {
    print_header "Embedding Generation Status - $ACTIVE_PROFILE"

    # Overall progress
    print_section "Overall Progress"
    $PSQL_CMD -c "
    SELECT
        COUNT(*) as total_chunks,
        COUNT(embedding) as with_embeddings,
        COUNT(*) - COUNT(embedding) as without_embeddings,
        ROUND(100.0 * COUNT(embedding) / NULLIF(COUNT(*), 0), 2) as pct_complete
    FROM chunks;
    "

    # Queue status
    print_section "Queue Status"
    $PSQL_CMD -c "
    SELECT
        COUNT(*) FILTER (WHERE metadata->>'embedding_queued' = 'true' AND embedding IS NULL) as queued,
        COUNT(*) FILTER (WHERE metadata->>'embedding_queued' = 'true' AND embedding IS NOT NULL) as processed,
        COUNT(*) FILTER (WHERE embedding IS NOT NULL) as total_embedded
    FROM chunks;
    "

    # Recent embeddings
    print_section "Recent Embeddings (Last 10)"
    $PSQL_CMD -c "
    SELECT
        embedding_generated_at::timestamp(0) as generated_at,
        embedding_model,
        token_count,
        LEFT(content, 60) as content_preview
    FROM chunks
    WHERE embedding IS NOT NULL
    ORDER BY embedding_generated_at DESC NULLS LAST
    LIMIT 10;
    "

    # Embedding models
    print_section "Models Used"
    $PSQL_CMD -c "
    SELECT
        embedding_model,
        COUNT(*) as count,
        MIN(embedding_generated_at) as first_use,
        MAX(embedding_generated_at) as last_use
    FROM chunks
    WHERE embedding IS NOT NULL
    GROUP BY embedding_model
    ORDER BY count DESC;
    "
}

#------------------------------------------------------------------------------
# Command: reset
#------------------------------------------------------------------------------

cmd_reset() {
    print_header "Reset Embedding Queue - $ACTIVE_PROFILE"

    echo -e "${YELLOW}This will clear all 'embedding_queued' flags from chunk metadata.${NC}"
    echo -e "${YELLOW}It will NOT remove existing embeddings.${NC}\n"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    $PSQL_CMD -c "
    UPDATE chunks
    SET metadata = metadata - 'embedding_queued' - 'embedding_queued_at' - 'embedding_filter'
    WHERE metadata ? 'embedding_queued';
    "

    echo -e "\n${GREEN}✓ Queue flags cleared${NC}"
}

#------------------------------------------------------------------------------
# Command: help
#------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
Embedding Generation Pipeline for Humanizer Agent

USAGE:
    ./embedgen COMMAND [OPTIONS]

COMMANDS:
    plan [--min-tokens N]       Plan what will be embedded (dry run, default: 15 tokens)
    queue [--min-tokens N]      Mark chunks for embedding (default: 15 tokens)
    process [--batch-size N]    Process queued chunks (default: 100)
    status                      Show embedding progress
    reset                       Clear all embedding queue flags
    help                        Show this help message

WORKFLOW:
    1. ./embedgen plan --min-tokens 15      # See what will be embedded
    2. ./embedgen queue --min-tokens 15     # Mark chunks for embedding
    3. ./embedgen process --batch-size 100  # Generate embeddings
    4. ./embedgen status                    # Check progress

FILTERING RULES:
    - Skips chunks with token_count = 0
    - Skips chunks below minimum token threshold (default: 15)
    - Skips slash commands (content starts with '/')
    - Skips low-interest words ("continue", "yes", "ok", "next", etc.)
    - Skips chunks that already have embeddings

CONFIGURATION:
    Model: mxbai-embed-large (Ollama)
    Dimension: 1024
    Ollama URL: http://localhost:11434

REQUIREMENTS:
    - Ollama must be running: ollama serve
    - Model must be pulled: ollama pull mxbai-embed-large

ACTIVE DATABASE:
    Profile: $ACTIVE_PROFILE
    Database: $DB_NAME

    To switch databases, use: ./dbswitch switch <profile>

EXAMPLES:
    # See what will be embedded with 20-token minimum
    ./embedgen plan --min-tokens 20

    # Queue all chunks with 15+ tokens
    ./embedgen queue --min-tokens 15

    # Process in larger batches
    ./embedgen process --batch-size 200

    # Check progress
    ./embedgen status

EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

echo -e "${GREEN}🧬 Embedding Generator${NC} - Active profile: ${CYAN}$ACTIVE_PROFILE${NC} (${DB_NAME})"

if [[ $# -eq 0 ]]; then
    cmd_help
    exit 0
fi

COMMAND=$1
shift

# Parse options
MIN_TOKENS=$DEFAULT_MIN_TOKENS
BATCH_SIZE=$DEFAULT_BATCH_SIZE

while [[ $# -gt 0 ]]; do
    case "$1" in
        --min-tokens)
            MIN_TOKENS="$2"
            shift 2
            ;;
        --batch-size)
            BATCH_SIZE="$2"
            shift 2
            ;;
        *)
            echo -e "${RED}❌ Error: Unknown option '$1'${NC}"
            cmd_help
            exit 1
            ;;
    esac
done

case "$COMMAND" in
    plan)
        cmd_plan "$MIN_TOKENS"
        ;;
    queue)
        cmd_queue "$MIN_TOKENS"
        ;;
    process)
        cmd_process "$BATCH_SIZE"
        ;;
    status)
        cmd_status
        ;;
    reset)
        cmd_reset
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        echo -e "${RED}❌ Error: Unknown command '$COMMAND'${NC}"
        cmd_help
        exit 1
        ;;
esac
